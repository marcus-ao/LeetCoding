# 001. 两数之和 (Two Sum) - 深度解析文档

## 📋 题目信息

- **难度**：简单 (Easy)
- **标签**：数组 (Array)、哈希表 (Hash Table)
- **来源**：LeetCode Hot 100
- **核心考察点**：
    - 数据结构的查找效率 (Search Efficiency)
    - 空间换时间 (Space-Time Tradeoff)
    - 边界条件处理 (Edge Cases)

## 📖 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target` 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

### 示例

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

### 约束条件深度分析

1.  **`2 <= nums.length <= 10^4`**
    -   **解读**：数组长度 $N$ 达到 $10^4$。
    -   **算法隐喻**：如果使用 $O(N^2)$ 的算法，计算量约为 $10^8$。在一般判题机（通常 1秒限制约 $10^8$ 次运算）上，这处于超时的边缘。特别是对于 Python 这种解释型语言，极大概率会 TLE (Time Limit Exceeded)。因此，**必须寻求优于 $O(N^2)$ 的解法**。
    -   **空间预判**：$O(N)$ 空间仅需存储 10,000 个整数，内存消耗极低（KB级别），远低于 256MB/512MB 的限制。这暗示我们可以**放心大胆地使用空间换时间**。

2.  **`-10^9 <= nums[i] <= 10^9`**
    -   **解读**：数值范围跨度极大（20亿）。
    -   **陷阱**：无法使用数组作为哈希表（如 `bucket[2000000000]`），因为这会瞬间撑爆内存 (Memory Limit Exceeded)。必须使用**基于散列的哈希表** (HashMap/Dictionary)，它只存储实际存在的 Key，而不关心 Key 的数值大小。
    -   **数据类型**：在 C++ 或 Java 中，两个 $10^9$ 相加可能溢出 `int` 范围（$2^{31}-1 \approx 2.14 \times 10^9$）。虽然题目保证有解且输入在范围内，但在计算中间结果时需留意。不过 `target - nums[i]` 减法通常是安全的（除非 target 是负数最小值且 nums[i] 是正数）。

3.  **只会存在一个有效答案**
    -   **解读**：这简化了问题。一旦找到第一对匹配，即可立即返回 (Early Return)，不需要继续遍历寻找其他可能的组合。

---

## 🤔 题目分析

### 问题理解

我们需要在给定的数组中找到两个数 $A$ 和 $B$，使得：
1.  $A + B = \text{target}$
2.  $A$ 的下标 $\neq$ $B$ 的下标

### 关键观察

这是典型的**查找**问题。
如果我们固定了一个数 $A$（比如遍历到了 `nums[i]`），那么另一个数 $B$ 的值就确定了：$B = \text{target} - A$。

此时，问题就转化为了：
**在遍历数组的过程中，对于当前的 `nums[i]`，我能否快速知道 `target - nums[i]` 之前是否出现过？**

- 如果出现过，它的下标是多少？
- 如果没出现过，我把 `nums[i]` 记录下来，供后面的数查找。

---

## 💡 解题思路

### 方法一：暴力枚举 (Brute Force)

#### 🌟 形象化理解：毫无章法的相亲

**场景类比**：
想象你是一个只知道苦干的红娘。你的手里有一份名单（数组）。
为了找到能配对的两个人（和为 target），你采取了最笨的办法：

1.  把名单上的**第一个人**拉出来，让他和名单上**剩下的所有人**逐个见面。如果合适，就在一起。如果不合适，继续下一个。
2.  如果不成功，把**第二个人**拉出来，让他和**后面所有人**逐个见面。
3.  以此类推...

**核心理解**：
这种方法虽然稳妥（一定能找到），但极其浪费时间。每个人都要和后面所有人重复比较，做了大量的无用功。

#### 算法步骤

1.  使用双重循环。
2.  外层循环 `i` 从 `0` 到 `n-1`。
3.  内层循环 `j` 从 `i+1` 到 `n-1`。
4.  检查 `nums[i] + nums[j] == target`。
5.  如果相等，返回 `[i, j]`。

#### 复杂度分析

-   **时间复杂度**：$O(N^2)$。
    -   计算公式：$(N-1) + (N-2) + ... + 1 = \frac{N(N-1)}{2} \approx \frac{1}{2}N^2$。
    -   当 $N=10^4$ 时，运算量级为 $10^8$，如前所述，效率堪忧。
-   **空间复杂度**：$O(1)$。
    -   只使用了常数个变量 (`i`, `j`)。

#### 为什么需要优化

暴力解法的瓶颈在于**查找效率**。
当我们寻找 `target - nums[i]` 时，我们在内层循环中线性扫描了数组。线性扫描的查找复杂度是 $O(N)$。加上外层循环，总复杂度就是 $N \times O(N) = O(N^2)$。
如果能把内层的查找优化到 $O(1)$，总复杂度就能降到 $O(N)$。

---

### 方法二：哈希表优化 (Hash Table) ⭐ 推荐

#### 🌟 形象化理解：聪明的登记员

> **💡 优化思路的核心：利用“记忆”代替“重复查找”**

**场景类比**：

想象现在你是一个聪明的红娘，手里拿了一个**登记本（哈希表）**。
每个人进场的时候，你先看一眼登记本：有没有人正等着这个新来的人？
- (这个“等着的人”就是 `target - 新来的人`)

1.  **查询**：新来了一个人 $X$。算一下他需要的另一半是 $Y = \text{target} - X$。
2.  **翻本子**：查一下登记本，有人叫 $Y$ 吗？
    -   **有**！太好了，登记本上记着 $Y$ 的电话（下标）。配对成功！
    -   **没有**。没关系，把 $X$ 的名字和电话（下标）记在登记本上，等待下一位有缘人。

**对应关系**：
-   **登记本** = 哈希表 (HashMap)
-   **名字** = 数值 (Key)
-   **电话** = 下标 (Value)
-   **查询操作** = 哈希查找 (平均 $O(1)$)

**核心理解**：
我们不需要每次都回头去问之前的人。只要把见过的人记在哈希表里，下次只用 $O(1)$ 的时间就能查到。这就是**空间换时间**的精髓。

#### 优化思路推导

1.  暴力解法的瓶颈是内层循环的查找（判断 `target - nums[i]` 是否存在）。
2.  我们可以引入一个数据结构，能够以 $O(1)$ 的速度回答“某个值是否存在”的问题。
3.  **哈希表** 正是为此而生。
4.  为了返回下标，我们需要哈希表存储 `数值 -> 下标` 的映射。
5.  最终方案：遍历数组，边查边存。

#### 算法步骤

1.  初始化一个空的哈希表 `map`。
2.  遍历数组 `nums`，获取当前元素 `val` 和下标 `i`。
3.  计算补数 `complement = target - val`。
4.  检查 `complement` 是否在 `map` 中：
    -   如果存在，说明之前已经遍历过这个补数。直接返回 `[map[complement], i]`。
    -   如果不存在，将当前数存入 `map`：`map[val] = i`。
5.  如果在遍历结束还没找到（题目保证有解，理论不执行），返回空。

#### 复杂度分析

-   **时间复杂度**：$O(N)$。
    -   我们只遍历了一次数组。
    -   哈希表的插入和查找操作，在平均情况下是 $O(1)$ 的。
    -   总耗时：$N \times O(1) = O(N)$。
-   **空间复杂度**：$O(N)$。
    -   最坏情况下（比如答案在数组的最后两个数），我们需要把前 $N-1$ 个数都存入哈希表。

---

## 🎨 图解说明

### 执行过程示例

**输入**：`nums = [2, 7, 11, 15]`, `target = 9`

| 步骤    | 当前 `i` | 当前 `num` | 需要找 `complement`  | 哈希表状态 `map` | 动作                  |
| :------ | :------- | :--------- | :------------------- | :--------------- | :-------------------- |
| **1**   | 0        | **2**      | $9 - 2 = \mathbf{7}$ | `{}`             | 查无7。存入 `2:0`。   |
| **2**   | 1        | **7**      | $9 - 7 = \mathbf{2}$ | `{2:0}`          | **查到2！** 下标为0。 |
| **End** |          |            |                      |                  | **返回 `[0, 1]`。**   |

### 可视化流程图

```mermaid
graph TD
    Start[开始遍历 nums] --> Init[初始化空 Map]
    Init --> CheckLoop{还有元素吗?}
    
    CheckLoop -- No --> End[返回空/报错]
    CheckLoop -- Yes --> GetNum[获取当前 num 和 i]
    
    GetNum --> CalcComp[计算 complement = target - num]
    CalcComp --> CheckMap{Map 中有 complement?}
    
    CheckMap -- Yes (找到了!) --> Found[返回 [map[complement], i]]
    Found --> Finish((结束))
    
    CheckMap -- No (没找到) --> Store[存入 Map: map[num] = i]
    Store --> CheckLoop
    
    style Found fill:#9f9,stroke:#333
    style CheckMap fill:#ff9,stroke:#333
```

---

## ✏️ 代码框架填空 (Interactive Learning)

> **💡 学习提示**：在查看完整代码之前，请先尝试完成以下填空。这能帮助你真正掌握算法逻辑，而不是一眼而过。

### Python 填空版 (Level 2: 关键逻辑挖空)

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    # 🔹 填空1：初始化数据结构
    # 提示：我们需要一个能快速(O(1))查找的数据结构来存储"数值 -> 下标"
    seen = ______
    
    for i, num in enumerate(nums):
        # 🔹 填空2：计算我们需要的另一半
        # 提示：如果 num + ? = target，那么 ? 是多少？
        complement = ______
        
        # 🔹 填空3：检查是否找到了目标
        # 提示：去我们的"登记本"(seen)里查一下
        if ______:
            # 🔹 填空4：返回结果
            # 提示：返回"之前那个数的下标"和"当前数的下标"
            return [______, i]
        
        # 🔹 填空5：没找到，记录当前情况
        # 提示：把当前数和下标存进去
        seen[______] = ______
    
    return []
```

### 填空提示详解

1.  **填空1**：`{}`。
    -   **为什么**：Python 的字典 (dict) 就是哈希表实现，查找速度最快。
2.  **填空2**：`target - num`。
    -   **逻辑**：简单的代数移项。
3.  **填空3**：`complement in seen`。
    -   **易错点**：不要写成 `num in seen`，我们要找的是互补的那个数。
4.  **填空4**：`seen[complement]`。
    -   **逻辑**：从哈希表中取出之前存进去的那个数的下标。
5.  **填空5**：`num` 和 `i`。
    -   **逻辑**：Key 是数值（因为我们要查数值），Value 是下标（因为题目要返回下标）。即 `seen[num] = i`。

---

## 💻 完整代码实现

### Python 实现 (标准工程版)

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        """
        使用哈希表在 O(N) 时间复杂度内解决两数之和问题。
        
        Args:
            nums: 整数数组
            target: 目标和
            
        Returns:
            包含两个整数下标的列表，顺序任意。
        """
        # 创建哈希表，Key为数值，Value为下标
        # 空间复杂度: O(N)
        idx_map = {}
        
        # 使用 enumerate 同时获取下标和数值
        # 时间复杂度: O(N)
        for i, num in enumerate(nums):
            # 1. 计算能在前面的数字中与当前数字凑成 target 的那个数
            complement = target - num
            
            # 2. 检查这个数是否已经在哈希表中
            # Python 的 'in' 操作符对于 dict 是 O(1) 的
            if complement in idx_map:
                # 如果存在，说明找到了这对数。
                # idx_map[complement] 是之前那个数的下标，i 是当前数的下标
                return [idx_map[complement], i]
            
            # 3. 如果没找到，就把当前数字和下标存入哈希表，供后面的数字查找
            # 注意：先查后存，可以自然地处理"不能使用两次相同元素"的要求
            # （因为当前元素还没有存进去，所以不会查到自己）
            idx_map[num] = i
            
        # 题目保证有唯一解，所以理论上不会运行到这里
        return []
```

### C++ 实现 (STL标准版)

```cpp
#include <vector>
#include <unordered_map>

using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 使用 unordered_map 保证平均 O(1) 的查找效率
        // map 若 Key 不存在，operator[] 会插入默认值，所以推荐用 find()
        unordered_map<int, int> idx_map;
        
        for (int i = 0; i < nums.size(); ++i) {
            // 计算需要的补数
            // 注意：虽然题目中数值可能很大，但 sub 操作通常安全（除非溢出 int 极值）
            int complement = target - nums[i];
            
            // 在哈希表中查找补数
            // find() 返回一个迭代器，如果没找到则等于 end()
            auto it = idx_map.find(complement);
            
            if (it != idx_map.end()) {
                // 找到了！it->second 获取 Value (即下标)
                return {it->second, i};
            }
            
            // 没找到，将当前数存入哈希表
            idx_map[nums[i]] = i;
        }
        
        return {}; // 仅为了通过编译器检查
    }
};
```

---

## ⚠️ 常见错误与面试陷阱

### 1. 误用 `nums.index()`
**错误代码**：
```python
if complement in nums:
    return [nums.index(complement), i]
```
**深度解析**：
虽然逻辑看起来是对的，但 `nums.index()` 是一个 **$O(N)$** 的操作（线性扫描整个列表）。将其放在 `for` 循环中，会导致总的时间复杂度退化回 **$O(N^2)$**。这在面试中是**致命**的，因为它暴露了你对 API 底层复杂度及其后果的无知。

### 2. 自身元素重复使用
**错误逻辑**：
先将所有元素都存入 Map，然后再遍历查找。
**问题**：
如果 `target = 6`，数组是 `[3, 2, 4]`。
- 先存入：`{3:0, 2:1, 4:2}`
- 遍历到 3 时，查 `6-3=3`。Map 里有 3 吗？有（就是它自己）。
- 返回 `[0, 0]`。**错误！**
**修正**：
必须在存入之前检查，或者在查找时判断下标不相等。这也是为什么推荐**一次遍历（One-pass）**写法的原因——天然避开了这个问题。

### 3. 返回值与 Key 的混淆
**错误**：
哈希表存了 `下标 -> 数值`。
**修正**：
我们要查的是**数值**，根据哈希表的原理，查询只能针对 **Key** 进行。因此必须存 `数值 -> 下标`。

---

## 🔗 相似题目推荐

掌握了 **哈希表** 这一核心技巧后，你可以尝试解决以下题目：

### 同类型题目 (哈希表应用)
1.  **[001. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)** (中等)
    -   **思路对比**：由于数组有序，可以抛弃哈希表，改用**双指针**。空间复杂度从 $O(N)$ 降为 $O(1)$。
2.  **[167. 两数之和 IV - 输入 BST](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)** (简单)
    -   **思路对比**：数据结构变成了树，但本质还是找两个数。可以用 DFS + 哈希表，或者中序遍历转有序数组 + 双指针。

### 进阶题目 (kSum 系列)
1.  **[015. 三数之和 (3Sum)](https://leetcode.cn/problems/3sum/)** (中等)
    -   **进阶点**：从 2 个数变成 3 个数。通常做法是：先排序，然后固定一个数，剩下的变成 Two Sum 问题（双指针）。复杂度 $O(N^2)$。
2.  **[018. 四数之和 (4Sum)](https://leetcode.cn/problems/4sum/)** (中等)
    -   **进阶点**：再多一层循环。复杂度 $O(N^3)$。

### 变种题目 (子数组系列)
1.  **[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)** (中等)
    -   **关联**：不再是两个数，而是连续子数组。
    -   **核心转化**：`Sum[i...j] = PrefixSum[j] - PrefixSum[i-1] == K`。
    -   **本质**：这变成了一个在**前缀和数组**中找 Two Sum 的问题！依然用哈希表解决。

---

## 📚 知识点总结

### 核心算法：空间换时间
这是算法设计中最通用的权衡策略。当时间复杂度（如 $O(N^2)$）无法满足要求，且内存空间充足时，我们总是优先考虑引入额外的数据结构（如哈希表）来记录历史信息，将查找操作从 $O(N)$ 降低到 $O(1)$。

### 数据结构：哈希表 (Hash Table)
-   **原理**：利用哈希函数将 Key 映射到数组下标。
-   **优点**：查找、插入、删除的平均时间复杂度均为 $O(1)$。
-   **应用**：去重、计数、快速查找、两数之和。

### 学习建议
1.  **手写代码**：不要只看懂思路，一定要自己动手写一遍哈希表的解法。
2.  **调试验证**：试着用 Python 的 `print` 或 IDE 的调试功能，观察哈希表在每一步的变化（参考上文的图解表格）。
3.  **举一反三**：尝试做一下“三数之和”，感受从 Two Sum 到 Three Sum 的思维跨越。

---

## 🔬 深度算法原理剖析

### 1. 数学证明：为什么这种方法是正确的？

很多初学者会疑惑：*“我只遍历一次数组，怎么保证一定能找到那两个数？会不会出现 A 在前，B 在后，遍历到 A 时找不到 B，遍历到 B 时又错过了 A 的情况？”*

**证明如下**：
假设数组中存在唯一的解 $A$ 和 $B$（$A + B = \text{target}$），且 $A$ 在数组中的位置 $i$ 小于 $B$ 的位置 $j$（即 $i < j$）。

当我们遍历数组时，指针 $k$ 从 $0$ 移动到 $N-1$。
1.  当 $k = i$ 时（遍历到 $A$）：
    -   我们检查哈希表中是否存在 $B$。
    -   由于 $B$ 在 $A$ 的后面 ($j > i$)，此时 $B$ 还没有被遍历到，哈希表中肯定没有 $B$。
    -   **操作**：我们将 $A$ 存入哈希表。
2.  当 $i < k < j$ 时（遍历到 $A$ 和 $B$ 之间的数）：
    -   哈希表中存储了 $A$ 和之前的其他数。
3.  当 $k = j$ 时（遍历到 $B$）：
    -   我们检查哈希表中是否存在 $A$ （因为 $A = \text{target} - B$）。
    -   根据步骤 1，$A$ 已经在之前被存入哈希表了。
    -   **操作**：查找到 $A$，返回 `[index(A), index(B)]`。

**结论**：
对于任何一对解 $(A, B)$，假设 $A$ 先出现，$B$ 后出现。我们虽然在 $A$ 出现时“错过”了配对（因为不知 $B$ 在哪），但我们把 $A$ **缓存**了下来。等到 $B$ 出现时，我们在回望历史（查哈希表）时必然能发现 $A$。因此，一次遍历足以覆盖所有情况。

### 2. 底层机制：哈希表是如何实现 O(1) 的？

你可能听说过哈希表是 $O(1)$，但你知道为什么吗？

#### 哈希函数 (Hash Function)
哈希表底层是一个**数组**（Bucket Array）。
当我们执行 `map[key] = value` 时：
1.  计算机通过哈希函数 $H(key)$ 计算出一个整数（HashCode）。
2.  通过取模运算 `idx = H(key) % ArraySize` 计算出数组下标。
3.  将 `(key, value)` 存入 `Buckets[idx]`。

#### 哈希冲突 (Collision)
问题来了：如果 `H(key1) % size == H(key2) % size` 怎么办？这就是哈希冲突。
主流的解决方法是 **拉链法 (Chaining)**：
-   每个 Bucket 不再只存一个数，而是存一个**链表**。
-   当冲突发生时，新的元素被追加到链表的末尾。

#### 复杂度分析
-   **平均情况**：如果哈希函数设计得好，元素会均匀分布在不同的 Bucket 中。每个 Bucket 里的链表长度非常短（接近 1）。查找时只需定位 Bucket + 遍历极短的链表 $\approx O(1)$。
-   **最坏情况**：如果所有 Key 都冲突到同一个 Bucket，哈希表就退化成了链表。查找复杂度变为 $O(N)$。
-   **工程优化**：在 Java 8+ 的 `HashMap` 中，当链表长度超过 8 时，会自动转化为 **红黑树**。这样即使发生大规模冲突，查找复杂度也能维持在 $O(\log N)$。

---

## ⚔️ 面试官追问 (Mock Interview)

**Q1: 如果数组没有排序，可以用双指针吗？**
> **A**: 不行。双指针依赖于“数组有序”这个前提。如果原数组无序，我们需要先排序，耗时 $O(N \log N)$。这比哈希表的 $O(N)$ 慢。而且排序会打乱下标，需要额外记录原始下标，增加了实现的复杂度。

**Q2: 如果内存限制非常严格（比如嵌入式环境），不能用 $O(N)$ 空间怎么办？**
> **A**: 这时只能牺牲时间换空间。我们可以退回到暴力解法 $O(N^2)$，或者先原地排序（如果不要求返回原始下标）再用双指针。如果必须返回原始下标且内存极小，可能原本的 $O(N)$ 算法就不可行了。

**Q3: 如果输入数据量非常大（比如 100亿），内存存不下怎么办？**
> **A**: 这是一个大数据处理问题。
> 1. **分片 (Sharding)**：利用 Hash(num) % K 将数据分流到 K 个小文件中。
> 2. **处理**：对于每个数字 $x$，我们需要找 $y = \text{target} - x$。
>    - 如果 $x$ 和 $y$ 被分到了同一个文件（Ideal Case），分别加载小文件处理。
>    - 难点在于 $x$ 和 $y$ 可能在不同文件。通用的分布式解法可以使用 **Bloom Filter** 预先并在内存中判断“可能存在”，或者使用 MapReduce 分布式哈希连接。

---

## 🛡️ 安全与工程考量

### 哈希洪泛攻击 (Hash Flooding Attack) **(Advanced)**

在 Web 后端开发中，如果攻击者知道了你使用的哈希算法（通常是开源的），他可以精心构造一组 Key，使得它们的 Hash 值全部相同（碰撞）。
-   如果你用这个哈希表来存储用户请求参数（两数之和的场景可能不适用，但对于 JSON 解析等场景适用）。
-   你的哈希表会瞬间退化成链表，插入和查找从 $O(1)$ 变成 $O(N)$。
-   当 $N$ 很大时，服务器 CPU 会被 100% 占用，导致拒绝服务 (DoS)。

**防御措施**：
现代语言（Python 3.3+, Java, Rust）的哈希函数通常引入了 **随机种子 (Random Seed)**。每次程序启动时种子不同，攻击者就无法预测 Hash 值，从而防御此类攻击。

---

## 💡 总结与建议

不要小看这道 "Easy" 题。它涵盖了算法设计中最重要的两个概念：
1.  **查找**的本质（线性扫描 vs 索引查找）。
2.  **Trade-off**（空间换时间）。

如果你能从暴力解法讲到哈希表，再延伸到哈希冲突、工程实现和安全问题，面试官一定会对你刮目相看。

---

**文档生成时间**：2026-02-08
**复习建议**：建议在 3 天后复习本题，尝试不看任何资料独立完成代码填空。
