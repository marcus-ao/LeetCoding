# 724. 寻找数组的中心下标

## 📋 题目信息
- **难度**：简单
- **标签**：数组、前缀和
- **来源**：LeetCode 724 / 1991

## 📖 题目描述

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

### 示例

**示例 1：**
```text
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

**示例 2：**
```text
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

**示例 3：**
```text
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

### 约束条件

- `1 <= nums.length <= 10^4`
- `-1000 <= nums[i] <= 1000`

---

## 🤔 题目分析

### 问题理解

我们需要在数组中找到一个“平衡点”（即中心下标 `pivot`），使得这个点左边所有数字的和，正好等于它右边所有数字的和。注意：**中心点本身的值不计算在左右两侧的和之内**。如果处于最左或最右端，另一侧的和默认算作 `0`。

关键点：
- 左侧和（不含中心点） == 右侧和（不含中心点）。
- 如果有多个满足条件的点，返回最左边的那一个（这意味着我们从左往右遍历，找到的第一个就是答案）。
- 找不到返回 `-1`。

### 关键观察

要判断 `i` 是不是中心下标，最直接的想法是把 `i` 左边求个和，右边求个和。但这会存在大量重复计算。
其实，整个数组的“总和”是固定不变的。如果我们知道了**数组总和（total_sum）**和当前位置 `i` 的**左侧和（left_sum）**，那么**右侧和（right_sum）**是可以通过数学减法直接算出来的：
`右侧和 = 总和 - 左侧和 - 当前位置的值`

---

## 💡 解题思路

### 方法一：暴力解法

#### 🌟 形象化理解

**场景类比**：
想象你要在一个跷跷板上找一个完美的支点。
暴力解法的做法是：你用手指挨个指着木板上的每一个刻度。每次指到一个刻度，你就跑去把左边所有的重物挨个称一遍，再跑去把右边所有的重物挨个称一遍。看看两边的重量是不是一样重。

**核心理解**：
每次换刻度，你都要重新把所有东西称一次，做了大量的无用功。

---

#### 算法步骤
1. 外层循环遍历数组的每一个下标 `i`。
2. 内层循环一：从 `0` 到 `i-1` 计算左侧和。
3. 内层循环二：从 `i+1` 到 `n-1` 计算右侧和。
4. 比较两者，若相等则返回 `i`。

#### 复杂度分析
- **时间复杂度**：O(n²) - 对于每一个下标，我们都要遍历整个数组去计算左右两侧的和。
- **空间复杂度**：O(1) - 只需要几个变量来保存和。

#### 为什么需要优化
数组长度最大为 $10^4$，O(n²) 的时间复杂度会导致运算次数达到 $10^8$ 级别，效率太低。我们需要寻找一种避免重复求和的方法。

---

### 方法二：优化解法（前缀和思想）

#### 🌟 形象化理解（重点：优化的核心思想）

> **💡 在进入专业算法分析之前，先通过一个生活化的例子来理解优化思路的本质**

**场景类比**：
想象切一个固定重量的大蛋糕。
你事先把整个蛋糕放上秤，得知它的**总重量是 1000 克**。
现在你拿着刀从左往右比划要在哪里切。随着刀往右移，刀左边的蛋糕重量你在心里是可以默默累加记住的（比如切下一小块是 100克，左边总共就是 100克，再下一小块是 200克，左边就是 300克）。
这时候你想知道刀右边的蛋糕有多重，还需要去称吗？
不需要！直接用 `总重量 - 左边切掉的 - 刀底下正要切的那块` 就算出来了！

**对应关系**：
- **蛋糕总重量** = 数组的总和 (`total_sum`)
- **心里默默累加的左侧重量** = 前缀和 (`left_sum`)
- **刀正指着的那块** = 当前下标的值 (`nums[i]`)
- **优化的本质** = 整体是固定的，知道了一部分，另一部分可以通过减法直接算出，省去了重复称重的麻烦。

**核心理解**：
整体和不变，利用已知的前缀和，可以用 O(1) 的时间算出右侧和。

---

#### 优化思路推导

根据上述类比，我们转化为数学公式：
1. 设数组所有元素的和为 `total_sum`。
2. 设当前遍历到下标 `i` 时，它左侧的元素之和为 `left_sum`。
3. 那么它右侧的元素之和就是 `right_sum = total_sum - left_sum - nums[i]`。
4. 题目要求 `left_sum == right_sum`，代入后得到：
   `left_sum == total_sum - left_sum - nums[i]`
5. 移项化简得：
   `2 * left_sum + nums[i] == total_sum`

我们只需要在从左到右遍历的过程中，维护一个 `left_sum`，每次检查上面这个等式是否成立即可。

#### 算法步骤

1. 步骤1：计算数组 `nums` 的全部元素之和，记为 `total_sum`。
2. 步骤2：初始化左侧和 `left_sum` 为 `0`。
3. 步骤3：从左到右遍历数组（确保找到的是最左边的中心下标）：
   - 在下标 `i` 处，检查 `2 * left_sum + nums[i] == total_sum` 是否成立。
   - 如果成立，说明 `i` 就是中心下标，直接返回 `i`。
   - 如果不成立，将 `nums[i]` 累加到 `left_sum` 中，准备检查下一个下标。
4. 步骤4：如果循环结束都没有找到，返回 `-1`。

#### 复杂度分析

- **时间复杂度**：O(n) - 只需要遍历数组两次：第一次求总和，第二次找中心下标。
- **空间复杂度**：O(1) - 只需要记录 `total_sum` 和 `left_sum` 两个整数变量，不需要额外的空间。

---

## 🎨 图解说明

### 执行过程示例

**示例输入**：`nums = [1, 7, 3, 6, 5, 6]`

**预处理**：
计算 `total_sum` = 1 + 7 + 3 + 6 + 5 + 6 = 28
初始 `left_sum` = 0

**执行步骤**：

| 下标 `i` | `nums[i]` | 当前 `left_sum` | 判断: `2*left_sum + nums[i] == total_sum` (即 28) | 更新 `left_sum` |
|:-------:|:---------:|:-------------:|:-----------------------------------------------:|:-------------:|
| 0 | 1 | 0 | 2 * 0 + 1 = 1 (不等于28，继续) | `0 + 1 = 1` |
| 1 | 7 | 1 | 2 * 1 + 7 = 9 (不等于28，继续) | `1 + 7 = 8` |
| 2 | 3 | 8 | 2 * 8 + 3 = 19 (不等于28，继续) | `8 + 3 = 11` |
| 3 | 6 | 11 | **2 * 11 + 6 = 28 (等于28，找到目标！)** | (找到答案，直接返回 3) |

因此，返回下标 3。

---

## ✏️ 代码框架填空

> **💡 学习提示**：在查看完整代码之前，先尝试根据上面的算法步骤，自己思考并填写下面的空白处。这将帮助你从"不知道怎么开始"过渡到"能够独立实现关键逻辑"。

### Python填空版

```python
from typing import List

class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        # 🔹 填空1：初始化需要的变量
        # 提示：我们需要提前知道数组的总和
        total_sum = ______
        
        # 🔹 填空2：初始化左侧和
        # 提示：从最左侧开始时，左边的和是多少？
        left_sum = ______
        
        # 🔹 填空3：主循环结构
        # 提示：需要同时获取元素的值和它的下标
        for i, num in ______:
            
            # 🔹 填空4：核心判断逻辑
            # 提示：左侧和、当前元素与总和之间满足什么等式时，说明找到了中心下标？
            if ______ == total_sum:
                # 🔹 填空5：满足条件时的操作
                # 提示：找到了直接返回什么？
                return ______
            
            # 🔹 填空6：更新状态
            # 提示：在去检查下一个元素之前，当前的左侧和应该如何更新？
            left_sum ______
        
        # 🔹 填空7：返回结果
        # 提示：如果遍历完了都没找到，题目要求返回什么？
        return ______
```

### 填空提示详解

**填空1 - 变量初始化**
- 思考：Python中有什么内置函数可以快速求一个列表的总和？

**填空2 - 左侧和初始状态**
- 思考：当刀架在蛋糕最左边还没开始切的时候，刀左边的蛋糕重量是多少？

**填空3 - 循环结构**
- 思考：同时需要下标 `i` 及其对应的值 `num`，Python中使用哪个内置函数最方便？

**填空4 - 核心判断等式**
- 思考：回顾前文推导的公式：`左侧和 * 2 + 当前值 == 总和`。

**填空6 - 状态更新**
- 思考：当我们准备检查下一个下标时，当前的数字 `num` 就正式属于"左侧的数字"了，它应该加到哪里去？

---

## 💻 完整代码实现

> **✅ 对照检查**：现在对比你的填空答案和下面的完整实现，看看思路是否一致。

### Python实现

```python
from typing import List

class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        # 预先计算数组的总和，这是利用整体求局部的关键
        total_sum = sum(nums)
        
        # 初始化当前位置左侧的元素总和为 0
        left_sum = 0
        
        # 遍历数组，寻找中心下标
        for i, num in enumerate(nums):
            # 判断条件：左侧和 * 2 + 当前元素 == 总和
            if 2 * left_sum + num == total_sum:
                return i  # 找到中心下标，直接返回
            
            # 还没找到，当前元素并入左侧和，继续检查下一个
            left_sum += num
            
        # 遍历完没有满足条件的下标，返回 -1
        return -1

# 测试用例
if __name__ == "__main__":
    sol = Solution()
    
    # 测试用例1
    print(f"测试1: {sol.pivotIndex([1, 7, 3, 6, 5, 6]) == 3}")
    
    # 测试用例2
    print(f"测试2: {sol.pivotIndex([1, 2, 3]) == -1}")
    
    # 测试用例3 (包含负数)
    print(f"测试3: {sol.pivotIndex([2, 1, -1]) == 0}")
```

**填空答案解析**：
- **填空1**：`sum(nums)` - 使用内置函数获取总和。
- **填空2**：`0` - 起始状态最左侧没有元素，和为0。
- **填空3**：`enumerate(nums)` - 同时提供索引和值。
- **填空4**：`2 * left_sum + num` - 数学推导出来的核心等式。
- **填空5**：`i` - 题目要求返回中心下标。
- **填空6**：`+= num` - 将当前元素计入下一轮的 `left_sum` 中。
- **填空7**：`-1` - 题目要求无解时返回-1。

---

### C++实现

```cpp
#include <vector>
#include <numeric>
#include <iostream>
using namespace std;

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        // 使用 accumulate 计算数组总和
        int total_sum = accumulate(nums.begin(), nums.end(), 0);
        int left_sum = 0;
        
        for (int i = 0; i < nums.size(); ++i) {
            // 判断左侧和 * 2 + 当前元素 == 总和
            if (2 * left_sum + nums[i] == total_sum) {
                return i;
            }
            // 累加左侧和
            left_sum += nums[i];
        }
        
        return -1;
    }
};
```

**与Python的主要差异**：
- 差异1：C++中求和常用 `<numeric>` 库中的 `std::accumulate`。
- 差异2：循环通过基础的 `for(int i = 0; i < nums.size(); ++i)` 实现，使用 `nums[i]` 取值。

---

## ⚠️ 易错点提醒

### 1. `left_sum` 的更新时机

**易错点**：先累加了 `left_sum`，再去判断等式。
- **原因**：题目规定“中心点本身的值不计算在左右两侧的和之内”。如果先加上了 `num`，那 `left_sum` 就包含了中心点，这与题意不符。
- **正确做法**：必须**先判断**当前点是否为中心点，**后更新** `left_sum`。

### 2. 负数带来的直觉误导

**易错点**：由于数组中存在负数，有些学习者觉得“左边和在增加时右边和不一定减少”，从而怀疑前缀和等式的正确性。
- **原因**：前缀和的等式 `2 * left_sum + nums[i] == total_sum` 是纯粹的代数恒等变形，不受正负号影响。只要总和固定，等式在全整数域都成立。

---

## 🔗 相似题目推荐

### 同类型题目（前缀和基础）

1. **LeetCode 1991 - 找到数组的中间位置** (Easy)
   - 相似点：题目描述完全一样，就是这道题的换壳版。

2. **LeetCode 560 - 和为 K 的子数组** (Medium)
   - 相似点：同样利用前缀和的特性，加上哈希表来快速寻找符合要求的区间。
   - 进阶点：不仅仅是看左右和，而是寻找区间和。

3. **LeetCode 238 - 除自身以外数组的乘积** (Medium)
   - 相似点：也可以采用“左侧信息”和“右侧信息”分别计算然后合并的思想，这题是求乘积。

### 相关知识点

- **知识点**：**前缀和 (Prefix Sum)**
  - 能够将 O(N) 的求区间和的操作降低到 O(1)，是处理连续子数组/连续区域求和问题的杀手锏。

---

## 📚 知识点总结

### 核心算法
- **前缀和思想**：在遍历数组的过程中，通过累计之前的状态（这里是前面的元素之和），来快速计算未知部分的状态（用整体减去已知部分）。本质是**空间换时间**或**复用已知信息换时间**。

### 学习要点
1. **整体代换**：当我们发现某一部分信息很难快速求出（比如右侧和）时，想一想是不是可以引入“整体”（总和）来做减法。
2. **数学恒等式化简**：在代码逻辑中，尽量消除除法（如 `left == (total - num) / 2` 可能会遇到奇偶整除的问题），转化为乘法或加法（`2 * left + num == total`）是更安全和通用的代码习惯。
3. **时机控制**：循环里的操作顺序（先判断还是先累加）直接决定了状态变量所代表的确切含义。在涉及到“排除自身”的题目时，一定是先判断后累加。
